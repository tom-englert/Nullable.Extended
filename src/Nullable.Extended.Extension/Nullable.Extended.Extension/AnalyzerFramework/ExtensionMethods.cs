using System.IO;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

using TomsToolbox.Essentials;

using Project = Microsoft.CodeAnalysis.Project;
using Solution = Microsoft.CodeAnalysis.Solution;

namespace Nullable.Extended.Extension.AnalyzerFramework
{
    public static class ExtensionMethods
    {
        private static readonly char[] Separators =
        {
            Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar, Path.VolumeSeparatorChar
        };

        public const string AutoGeneratedTag = "<auto-generated>";
        private static readonly int AutoGeneratedCommentMinLength = AutoGeneratedTag.Length + 2;

        internal static bool IsGenerated(this Document document)
        {
            return IsGeneratedFile(document.FilePath);
        }

        internal static bool IsGeneratedAssemblyInfo(this Document document)
        {
            var filePath = document.FilePath;

            if (filePath.IsNullOrWhiteSpace()) 
                return false;

            // Generated AssemblyInfo files have the name of the form:
            //  <ProjectName>.AssemblyInfo.cs
            // In addition, the file has to be in the obj output folder
            // but we will ignore that check at the moment.
            // It is enough to insist on the expected file name form.

            if (!filePath.EndsWith(".AssemblyInfo.cs")) 
                return false;

            var directorySeparatorIndex = filePath.LastIndexOfAny(Separators);

            return string.Compare(document.Project.Name, 0, filePath, directorySeparatorIndex + 1,
                document.Project.Name.Length, StringComparison.OrdinalIgnoreCase) == 0;
        }

        // The implementation has been adapted from Josef Pihrt's Roslynator:
        // https://github.com/JosefPihrt/Roslynator/blob/a6ed824a390831fa67e0dbb3710418239654a88e/src/CSharp/GeneratedCodeUtility.cs#L1
        public static bool IsGeneratedFile(string? filePath)
        {
            if (filePath.IsNullOrWhiteSpace()) return false;

            var directorySeparatorIndex = filePath.LastIndexOfAny(Separators);

            if (string.Compare("TemporaryGeneratedFile_", 0, filePath, directorySeparatorIndex + 1,
                "TemporaryGeneratedFile_".Length, StringComparison.OrdinalIgnoreCase) == 0)
                return true;

            var dotIndex = filePath.LastIndexOf(".", filePath.Length - 1, filePath.Length - directorySeparatorIndex - 1,
                StringComparison.Ordinal);

            if (dotIndex == -1)
                return false;

            return IsMatch(".Designer")
                   || IsMatch(".Generated")
                   || IsMatch(".g")
                   || IsMatch(".g.i")
                   || IsMatch(".AssemblyAttributes");

            bool IsMatch(string value)
            {
                var length = value.Length;

                var index = dotIndex - length;

                return index >= 0
                       && string.Compare(value, 0, filePath, index, length, StringComparison.OrdinalIgnoreCase) == 0;
            }
        }

        // The implementation has been adapted from Josef Pihrt's Roslynator:
        // https://github.com/JosefPihrt/Roslynator/blob/b2c2493c880ccd06215a11fa7b42b64a1fea0470/src/CSharp/CSharp/CSharpGeneratedCodeAnalyzer.cs#L21
        internal static bool BeginsWithAutoGeneratedComment(this SyntaxNode syntaxRoot)
        {
            var leadingTrivia = syntaxRoot.GetLeadingTrivia();

            if (!leadingTrivia.Any()) return false;

            foreach (var trivia in leadingTrivia)
            {
                if (trivia.Kind() != SyntaxKind.SingleLineCommentTrivia) continue;

                var text = trivia.ToString();

                if (text.Length >= AutoGeneratedCommentMinLength
                    && text[0] == '/'
                    && text[1] == '/')
                {
                    var index = 2;

                    while (index < text.Length
                           && char.IsWhiteSpace(text[index]))
                    {
                        index++;
                    }

                    if (string.Compare(text, index, AutoGeneratedTag, 0, AutoGeneratedTag.Length,
                        StringComparison.OrdinalIgnoreCase) == 0)
                        return true;
                }
            }

            return false;
        }

        public static bool IsCSharpProject(this Project project)
        {
            return project.Language == "C#";
        }

        public static bool ShouldBeAnalyzed(this Document document)
        {
            return document.SupportsSyntaxTree &&
                   document.SupportsSemanticModel &&
                   !document.IsGenerated() &&
                   !document.IsGeneratedAssemblyInfo();
        }

        public static IEnumerable<Document> GetDocumentsToAnalyze(this Solution solution)
        {
            return solution
                .Projects
                .Where(project => project.IsCSharpProject())
                .SelectMany(project => project.GetDocumentsToAnalyze());
        }

        public static IEnumerable<Document> GetDocumentsToAnalyze(this Project project)
        {
            return project.Documents.Where(document => document.ShouldBeAnalyzed());
        }
    }
}